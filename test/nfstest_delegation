#!/usr/bin/env python
#===============================================================================
# Copyright 2012 NetApp, Inc. All Rights Reserved,
# contribution by Jorge Mora <mora@netapp.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#===============================================================================
import os
import errno
import fcntl
import struct
import traceback
import nfstest_config as c
from packet.nfs.nfs3_const import *
from packet.nfs.nfs4_const import *
from nfstest.test_util import TestUtil

# Module constants
__author__    = "Jorge Mora (%s)" % c.NFSTEST_AUTHOR_EMAIL
__copyright__ = "Copyright (C) 2012 NetApp, Inc."
__license__   = "GPL v2"
__version__   = "1.8"

USAGE = """%prog --server <server> [--client <client>] [options]

Delegation tests
================
Basic delegation tests verify that a correct delegation is granted when
opening a file for reading or writing. Also, another OPEN should not be
sent for the same file when the client is holding a delegation. Verify
that the stateid of all I/O operations should be the delegation stateid.
Reads from a different process on the same file should not cause the client
to send additional READ packets when the client is holding a read delegation.
Furthermore, a LOCK packet should not be sent to the server when the client
is holding a delegation.

Recall delegation tests verify the delegation is recalled when a conflicting
operation is sent to the server from a different client. Conflicting operations
are reading, writing, removing, renaming and changing the permissions on the
same file. Note that reading a file from a different client can only recall
a write delegation. Removing the delegated file from a different client
recalls the delegation and the server may or may not allow any more writes
from the client after the delegation has been returned. Renaming either the
delegated file (as source) or into the delegated file (as target) recalls
the delegation. In the case where the delegated file is the target of rename,
the existing target is removed before the rename occurs, therefore the server
may or may not allow nay more writes from the client after the delegation has
been removed just like in the case when removing the delegated file.

Also, verify that a read delegation is not recalled when a different client is
granted a read delegation. After a delegation is recalled, the client may send
an OPEN with CLAIM_DELEGATE_CUR before returning the delegation specially when
there is a open pending on the client. In addition, the stateid returned by the
new open should be the same as the original OPEN stateid. Also, a delegation
should not be granted when re-opening the file before returning the delegation.
The client may flush all written data before returning the WRITE delegation.
The LOCK should be sent as well before returning a delegation which has been
recalled. Finally, a delegation should not be granted on the second client who
cause the delegation recall on the first client.

Examples:
    Run the basic delegation tests (no client option):
        %prog --server 192.168.0.2 --export /exports

    Use short options instead:
        %prog -s 192.168.0.2 -e /exports

    Run both the basic and recall tests using positional arguments with
    nfsversion=3 for the second client:
        %prog -s 192.168.0.2 -e /exports --client 192.168.0.10:::3

    Use named arguments instead:
        %prog -s 192.168.0.2 -e /exports --client 192.168.0.10:nfsversion=3

Notes:
    The user id in the local host and the host specified by --client must
    have access to run commands as root using the 'sudo' command without
    the need for a password.

    The user id must be able to 'ssh' to remote host without the need for
    a password."""

# Test script ID
SCRIPT_ID = "DELEGATION"

TESTNAMES_STAT = [
    "basic03",
    "basic04",
    "basic09",
    "basic10",
]
TESTNAMES_LOCK = [
    "basic05",
    "basic06",
    "basic11",
    "basic12",
]
TESTNAMES_LOCAL = sorted([
    "basic01",
    "basic02",
    "basic07",
    "basic08",
] + TESTNAMES_STAT + TESTNAMES_LOCK)

TESTNAMES_SETATTR = [
    "recall07",
    "recall08",
    "recall09",
    "recall10",
    "recall35",
    "recall36",
    "recall37",
    "recall38",
]
TESTNAMES_REMOVE = [
    "recall11",
    "recall12",
    "recall13",
    "recall14",
    "recall39",
    "recall40",
    "recall41",
    "recall42",
]
TESTNAMES_RENAME = [
    "recall15",
    "recall16",
    "recall17",
    "recall18",
    "recall19",
    "recall20",
    "recall21",
    "recall22",
    "recall43",
    "recall44",
    "recall45",
    "recall46",
    "recall47",
    "recall48",
    "recall49",
    "recall50",
]
TESTNAMES_PENDING = [
    "recall23",
    "recall24",
    "recall25",
    "recall26",
    "recall51",
    "recall52",
    "recall53",
    "recall54",
]
TESTNAMES_REMOTE = sorted([
    "recall01",
    "recall02",
    "recall03",
    "recall04",
    "recall05",
    "recall06",
    "recall27",
    "recall28",
    "recall29",
    "recall30",
    "recall31",
    "recall32",
    "recall33",
    "recall34",
] + TESTNAMES_SETATTR + TESTNAMES_REMOVE + TESTNAMES_RENAME + TESTNAMES_PENDING)

# Include the test groups in the list of test names
# so they are displayed in the help
GTESTS = ["recall", "setattr", "remove", "rename", "pending"]
TESTNAMES = ["basic", "stat", "lock"] + TESTNAMES_LOCAL + GTESTS + TESTNAMES_REMOTE

TESTGROUPS = {
    "basic": {
         "tests": TESTNAMES_LOCAL,
         "desc": "Run all basic delegation tests: ",
    },
    "stat": {
         "tests": TESTNAMES_STAT,
         "desc": "Run all basic delegation tests with file stat: ",
    },
    "lock": {
         "tests": TESTNAMES_LOCK,
         "desc": "Run all basic delegation tests with file lock: ",
    },
    "recall": {
         "tests": TESTNAMES_REMOTE,
         "desc": "Run all recall delegation tests: ",
    },
    "setattr": {
         "tests": TESTNAMES_SETATTR,
         "desc": "Run all tests using SETATTR to recall the delegation: ",
    },
    "remove": {
         "tests": TESTNAMES_REMOVE,
         "desc": "Run all tests recalling the delegation by removing the delegated file: ",
    },
    "rename": {
         "tests": TESTNAMES_RENAME,
         "desc": "Run all tests recalling the delegation by renaming the delegated file: ",
    },
    "pending": {
         "tests": TESTNAMES_PENDING,
         "desc": "Run all recall delegation tests having a pending open: ",
    },
}

# Dictionary having the number of clients required by each test
TEST_CLIENT_DICT = {x:1 for x in TESTNAMES_REMOTE}

PATTERN = 'FF00'

OPEN_STID  = 0
LOCK_STID  = 1
DELEG_STID = 2
stid_map = {
    OPEN_STID  : "OPEN",
    LOCK_STID  : "LOCK",
    DELEG_STID : "DELEG",
}

OPEN_READ  = 0
OPEN_WRITE = 1
OPEN_RDWR  = 2

open_flags = {
    OPEN_READ  : os.O_RDONLY,
    OPEN_WRITE : os.O_WRONLY|os.O_CREAT,
    OPEN_RDWR  : os.O_RDWR|os.O_CREAT,
}

open_str = {
    OPEN_READ  : "READ",
    OPEN_WRITE : "WRITE",
    OPEN_RDWR  : "RDWR",
}

deleg_map = {
    OPEN_READ  : OPEN_DELEGATE_READ,
    OPEN_WRITE : OPEN_DELEGATE_WRITE,
    OPEN_RDWR  : OPEN_DELEGATE_WRITE,
}

deleg_str = {
    OPEN_DELEGATE_READ  : "READ",
    OPEN_DELEGATE_WRITE : "WRITE",
}

def file_lock(fd, open_type, absfile, lock_offset=0, lock_len=0):
    """Lock file given by the file descriptor"""
    lock_type = fcntl.F_RDLCK if open_type == OPEN_READ else fcntl.F_WRLCK
    lockdata = struct.pack('hhllhh', lock_type, 0, lock_offset, lock_len, 0, 0)
    return fcntl.fcntl(fd, fcntl.F_SETLK, lockdata)

class BaseName(Exception):
    """Exception used to stop recall tests when --basename option is set"""
    pass

class DelegTest(TestUtil):
    """DelegTest object

       DelegTest() -> New test object

       Usage:
           x = DelegTest(testnames=['basic', 'basic_lock', ...])

           # Run all the tests
           x.run_tests(deleg=deleg_mode)
           x.exit()
    """
    def __init__(self, **kwargs):
        """Constructor

           Initialize object's private data.
        """
        TestUtil.__init__(self, **kwargs)
        self.test_opgroup.version = "%prog " + __version__
        hhelp = "Remote NFS client and options used for recall delegation tests. " \
                "Clients are separated by a ',' and each client definition is " \
                "a list of arguments separated by a ':' given in the following " \
                "order if positional arguments is used (see examples): " \
                "clientname:server:export:nfsversion:port:proto:sec:mtpoint"
        self.test_opgroup.add_option("--client", default=None, help=hhelp)
        hhelp = "Starting offset for lock [default: %default]"
        self.test_opgroup.add_option("--lock-offset", type="int", default=0, help=hhelp)
        hhelp = "Starting offset for lock on pending open [default: %default]"
        self.test_opgroup.add_option("--lock-poffset", type="int", default=8192, help=hhelp)
        hhelp = "Number of bytes to lock [default: %default]"
        self.test_opgroup.add_option("--lock-len", type="int", default=4096, help=hhelp)
        hhelp = "Truncate file when writing from the second file for the recall tests"
        self.test_opgroup.add_option("--truncate", action="store_true", default=False, help=hhelp)
        self.scan_options()

        # Disable createtraces option
        self.createtraces = False

        # Local rexec object
        self.lexecobj = None

        # Find how many remote Rexec objects should be started
        nclients = 0
        for tname in self.testlist:
            nclients = max(nclients, TEST_CLIENT_DICT.get(tname, 0))

        # Process the --client option
        client_list = self.process_client_option(count=nclients)
        self.verify_client_option(TEST_CLIENT_DICT)

        # Start remote procedure server(s) remotely
        self.clientobj = None
        for client_args in client_list:
            client_name = client_args.pop("client", "")
            self.create_host(client_name, **client_args)
            self.create_rexec(client_name)

        # Verify the lock ranges do not overlap
        end1 = self.lock_offset  + self.lock_len - 1
        end2 = self.lock_poffset + self.lock_len - 1
        if end1 >= self.lock_poffset and end2 >= self.lock_offset:
            # Ranges overlap
            self.opts.error("Lock ranges overlap: (lock-offset, lock-len) and (lock-poffset, lock-len)")

    def lock_file(self, fd, open_type, absfile, lock_offset=0, lock_len=0):
        """Lock file given by the file descriptor.

           fd:
               Opened file descriptor of file
           open_type:
               Open type
           absfile:
               File path to display as debug info
           lock_offset:
               Lock offset [default: 0]
           lock_len:
               Lock length [default: 0]
        """
        lock_str = "F_RDLCK" if open_type == OPEN_READ else "F_WRLCK"
        try:
            fmsg = ""
            self.dprint('DBG3', "Lock %s (F_SETLK, %s) start=%d len=%d" % (absfile, lock_str, lock_offset, lock_len))
            file_lock(fd, open_type, absfile, lock_offset, lock_len)
        except OSError as exerr:
            fmsg = ", failed with %s" % exerr
        dmsg = "Lock file with %s" % lock_str
        self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

    def open_file(self, absfile, open_type, io_type=None, lock=False, lexec=False, msg=''):
        """Open file, lock it and do some I/O on the file.
           Return the file descriptor of the opened file.

           absfile:
               File name to open
           open_type:
               Open type
           io_type:
               I/O type
           lock:
               Get a lock on the file if true [default: False]
           lexec:
               Use different process to open file [default: False]
           msg:
               Message to append on debug message [default: '']
        """
        pidstr = " from a different process" if lexec else ""
        msg = msg if len(msg) == 0 else " %s" % msg
        mode_str = open_str[open_type]
        if io_type is None:
            io_type = OPEN_READ if open_type == OPEN_READ else OPEN_WRITE
        io_str = open_str[io_type].capitalize()

        try:
            fmsg = ""
            dmsg = "Open file for %s%s%s" % (mode_str, pidstr, msg)
            self.dprint('DBG2', "%s [%s]" % (dmsg, absfile))
            if lexec:
                fd = self.lexecobj.run(os.open, absfile, open_flags[open_type])
            else:
                fd = os.open(absfile, open_flags[open_type])
        except OSError as exerr:
            fmsg = ", failed with %s" % exerr
        self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

        if lock:
            self.lock_file(fd, io_type, absfile, self.lock_offset, self.lock_len)

        try:
            fmsg = ""
            dmsg = "%s file%s%s" % (io_str, pidstr, msg)
            self.dprint("DBG3", "%s [%s]" % (dmsg, absfile))
            # Read/Write file
            if io_type == OPEN_READ:
                if lexec:
                    self.lexecobj.run(os.read, fd, self.rsize)
                else:
                    os.read(fd, self.rsize)
            else:
                data = self.data_pattern(0, self.wsize, PATTERN)
                if lexec:
                    self.lexecobj.run(os.write, fd, data)
                else:
                    os.write(fd, data)
        except OSError as exerr:
            fmsg = ", failed with %s" % exerr
        self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

        self.delay_io()
        return fd

    def get_deleg_remote(self):
        """Get a read delegation on the remote client."""
        fdko = None
        if self.clientobj and self.clientobj.nfs_version < 4:
            # There are no delegations in NFSv3 so there is no need
            # to open a file so the open owner sticks around
            self.dprint("DBG2", "Open file on the remote client [%s]" % self.absfile)
        else:
            # Open file so open owner sticks around so a delegation
            # is granted when opening the file under test
            fdko = self.rexecobj.run(os.open, self.abspath(self.files[0]), os.O_RDONLY)
            self.dprint("DBG2", "Get a read delegation on the remote client [%s]" % self.absfile)
        # Open the file under test
        fdrd = self.rexecobj.run(os.open, self.absfile, os.O_RDONLY)
        self.dprint("DBG3", "Read %s on the remote client" % self.absfile)
        data = self.rexecobj.run(os.read, fdrd, 1024)
        self.dprint("DBG4", "Close %s on the remote client" % self.absfile)
        self.rexecobj.run(os.close, fdrd)
        if fdko is not None:
            self.rexecobj.run(os.close, fdko)

    def setup_test(self, open_type, io_type, mount=False, nfiles=0, lexec=False):
        """Setup test by mounting server and hold open a file so that the open
           owner sticks around so a delegation is granted on next open using
           the same open owner -- this is done to avoid a bug on the client
           where open owner is reaped at close
        """
        if nfiles > 0:
            self.umount()
            self.mount()
            # Create new files before starting the test
            for i in range(nfiles):
                self.create_file()

        self.umount()
        if mount and self.clientobj is not None:
            # Unmount server on remote client
            self.clientobj.umount()

        if lexec and self.lexecobj is None:
            # Start local rexec connection just once
            rexecobj_save = self.rexecobj
            self.lexecobj = self.create_rexec()
            self.rexecobj = rexecobj_save
            self.lexecobj.rimport("fcntl")
            self.lexecobj.rcode(file_lock)

        self.trace_start()
        self.mount()
        if mount and self.clientobj is not None:
            # Mount server on remote client
            self.clientobj.mount()

        if nfiles == 0:
            if io_type == OPEN_READ:
                # Use existing file
                self.filename = self.files[1]
                self.absfile = self.abspath(self.filename)
            else:
                # Create new file
                self.get_filename()

        # Hold a file open so that the open owner sticks around
        # (bug on the client where OO's are reaped at close)
        self.dprint('DBG4', "Open %s so open owner sticks around" % self.abspath(self.files[0]))
        self.fdko = open(self.abspath(self.files[0]), 'r')

    def verify_io_requests(self, iomode, deleg_stid, filehandles, src_ipaddr=None, maxindex=None):
        """Verify I/O is sent to the correct server."""
        nio = 0
        dsindex = 0
        for fh in filehandles:
            if self.dslist:
                # The address is one of the DS's connection
                ds = self.dslist[dsindex]
            else:
                # The address is the mounted server
                ds = [{"ipaddr": self.server_ipaddr, "port": self.port}]
            for item in ds:
                save_index = self.pktt.get_index()
                nio += self.verify_io(iomode, deleg_stid, item["ipaddr"], item["port"], filehandle=fh, src_ipaddr=src_ipaddr, maxindex=maxindex, pattern=PATTERN)
                self.pktt.rewind(save_index)
            dsindex += 1
        return nio

    def verify_open(self, fh, stat=False):
        """Verify OPEN call"""
        if self.opencall is None:
            return
        self.test(fh, "OPEN should be sent")
        if stat and self.nfs_version > 4.0:
            expr = self.opencall.NFSop.claim.claim == CLAIM_FH
            self.test(expr, "OPEN should be sent with CLAIM_FH")
            expr = self.opencall.NFSop.fh == fh
            self.test(expr, "OPEN should be sent with the filehandle of the file to be opened")
        else:
            expr = self.opencall.NFSop.claim.claim == CLAIM_NULL
            self.test(expr, "OPEN should be sent with CLAIM_NULL")
            if expr:
                expr = self.opencall.NFSop.claim.name == self.filename
                self.test(expr, "OPEN should be sent with the name of the file to be opened")
            expr = self.opencall.NFSop.fh != fh
            self.test(expr, "OPEN should be sent with the filehandle of the directory")

    def find_ios(self, op_type, filehandle, ipaddr, port):
        """Return a list of all I/O packets"""
        ret = {}
        # Matched all packets sent to the server given by ipaddr and port
        src = "IP.src == '%s' and " % self.client_ipaddr
        dst = self.pktt.ip_tcp_dst_expr(ipaddr, port)
        fh  = " and NFS.fh == '%s' and " % self.pktt.escape(filehandle)
        matchstr = src + dst + fh + "NFS.argop == %d" % op_type

        save_index = self.pktt.get_index()
        self.pktt.clear_xid_list()
        try:
            # Matched all I/O packets and their replies
            while self.pktt.match(matchstr, reply=True):
                pkt = self.pktt.pkt
                xid = pkt.rpc.xid
                if pkt.rpc.type == 0:
                    # Save I/O call info
                    nfsop = pkt.NFSop
                    info = {
                        "stateid": nfsop.stateid,
                        "count":   nfsop.count,
                        "nfsidx":  pkt.NFSidx,
                        "callidx": pkt.record.index,
                    }
                    if ret.get(xid) is None:
                        ret[xid] = info
                    else:
                        ret[xid].update(info)
                else:
                    # Save I/O reply status
                    idx = ret[xid].get("nfsidx")
                    if idx is not None and len(pkt.nfs.array) > idx:
                        nfsop = pkt.nfs.array[idx]
                        ret[xid]["status"] = nfsop.status
        except:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.rewind(save_index)
        # Return the list of I/O packets having status values
        return [item for item in ret.values() if item.get("status") is not None]

    def find_io_counts(self, io_list, stateid, status):
        """Return the number of matched stateid and matched status packets"""
        stid = 0  # Number of I/O packets matching the stateid
        stat = 0  # Number of I/O packets matching the status
        okct = 0  # Number of I/O packets with status = NFS4_OK
        for item in io_list:
            istatus = item.get('status')
            if istatus is None:
                continue
            if item.get('stateid') == stateid:
                stid += 1
            if istatus == status:
                stat += 1
            if istatus == NFS4_OK:
                okct += 1
        return (stid, stat, okct)

    def verify_io_per_server(self, io_list, op_type, stid_type, stateid, status, ds=False, delegret=False):
        """Verify I/O packets for a given server"""
        dr_str = " after returning the delegation" if delegret else ""
        io_str = "READ" if op_type == OP_READ else "WRITE"
        st_str = stid_map.get(stid_type)
        sv_str = "server"
        if self.layout and self.dslist:
            sv_str = "DS" if ds else "MDS"

        if io_list:
            nlen = len(io_list)
            (stid, stat, okct) = self.find_io_counts(io_list, stateid, status[0])
            self.test(stid == nlen, "%ss should be sent to the %s with the %s stateid%s" % (io_str, sv_str, st_str, dr_str))
            if delegret and okct == nlen and stat == 0:
                # The RFC allows servers to process I/O operations successfully
                # when the file has been removed. In this case all I/O operations
                # have succeeded but an error was expected for those servers
                # failing I/O operations when the file is removed.
                self.test(True, "%ss may return NFS4_OK from the %s%s" % (io_str, sv_str, dr_str))
            else:
                # Check if all I/O operations returned one of the expected
                # status codes
                idx = 0
                if stat != nlen:
                    for i in range(1, len(status)):
                        (stid, stat, okct) = self.find_io_counts(io_list, stateid, status[i])
                        if stat == nlen:
                            idx = i
                            break
                self.test(stat == nlen, "%ss should return %s from the %s%s" % (io_str, nfsstat4.get(status[idx], status[idx]), sv_str, dr_str))

    def verify_io_packets(self, op_type, open_fh, stid_type, stateid, status=[NFS4_OK], ds_status=[NFS4_OK], delegret=False):
        """Verify I/O packets"""
        io_list = []
        if self.layout and self.dslist:
            # Get I/O packets sent to the DS
            dsindex = 0
            for fh in self.layout['filehandles']:
                for item in self.dslist[dsindex]:
                    if item is not None:
                        io_list += self.find_ios(op_type, fh, item['ipaddr'], item['port'])
                dsindex += 1
        # Verify I/O packets sent to the DS
        self.verify_io_per_server(io_list, op_type, stid_type, stateid, ds_status, ds=True, delegret=delegret)

        # Verify I/O packets sent to the server (or MDS if pNFS is available)
        io_list = self.find_ios(op_type, open_fh, self.server_ipaddr, self.port)
        self.verify_io_per_server(io_list, op_type, stid_type, stateid, status, delegret=delegret)

    def verify_lock(self, io_type, mode_str, open_stid, offset, start_index, max_index, msg="", lock_owner=None, lock_stid=None):
        """Verify correct lock is sent to the server"""
        lock_stateid = None
        self.pktt.rewind(start_index)
        # Find LOCK call and reply using the lock offset
        mstr = "NFS.offset == %d" % offset
        (lockcall, lockreply) = self.find_nfs_op(OP_LOCK, match=mstr, status=None, src_ipaddr=self.client_ipaddr, maxindex=max_index)
        self.test(lockcall, "LOCK should be sent before returning the %s delegation%s" % (mode_str, msg))
        if lockcall:
            # Verify lock info sent to the server
            ltype = READ_LT if io_type == OPEN_READ else WRITE_LT
            self.test(lockcall.NFSop.locktype == ltype, "LOCK should be sent with correct lock type")
            self.test(lockcall.NFSop.length == self.lock_len, "LOCK should be sent with correct lock range")
            self.test(lockcall.NFSop.locker.open_owner.stateid == open_stid, "LOCK should be sent with correct OPEN stateid")
            if lock_owner is not None:
                # Verify lock has a different lock owner than the one given
                expr = lock_owner != lockcall.NFSop.locker.open_owner.lock_owner.owner
                self.test(expr, "LOCK should be sent with a different open owner")
        if lockreply:
            # Verify lock reply
            lstatus = lockreply.nfs.status
            fmsg = ", failed with %s" % nfsstat4.get(lstatus, lstatus)
            self.test(lstatus == NFS4_OK, "LOCK should return NFS4_OK", failmsg=fmsg)
            if lockreply.nfs.status == NFS4_OK:
                lock_stateid = lockreply.NFSop.stateid.other
                if lock_stid is not None:
                    # Verify lock stateid is different than the one given
                    expr = lock_stid != lock_stateid
                    self.test(expr, "LOCK should return a different lock stateid")
        return lock_stateid

    def basic_deleg_test(self, open_type, io_type=None, lock=False, stat=False, nfiles=0):
        """Basic delegation tests"""
        try:
            fds = []
            extra_str = ""
            self.fdko = None
            deleg_type = deleg_map[open_type]
            mode_str = deleg_str[deleg_type]
            if io_type is None:
                io_type = OPEN_READ if open_type == OPEN_READ else OPEN_WRITE
            if open_type == OPEN_RDWR:
                io_str = "reading" if io_type == OPEN_READ else "writing"
                extra_str = " using RDWR open while %s" % io_str
            if lock:
                extra_str += " with file lock"
            elif stat:
                extra_str += " with file stat"
            self.test_group("Basic %s delegation test%s" % (mode_str, extra_str))
            self.setup_test(open_type, io_type, nfiles=nfiles, lexec=True)

            if stat:
                try:
                    fmsg = ""
                    dmsg = "Stat file to cache file metadata"
                    self.dprint('DBG3', "%s [%s]" % (dmsg, self.absfile))
                    fstat = os.stat(self.absfile)
                except OSError as exerr:
                    fmsg = ", failed with %s" % exerr
                self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            # Open file, should get a DELEGATION
            fds.append(self.open_file(self.absfile, open_type, io_type, lock=lock))

            # Open same file on same process for reading
            fds.append(self.open_file(self.absfile, OPEN_READ, msg="on same process"))

            if open_type == OPEN_WRITE:
                # Open same file on same process for writing
                fds.append(self.open_file(self.absfile, OPEN_WRITE, msg="on same process"))

            # Access file from a different process
            fd = self.open_file(self.absfile, OPEN_READ, lexec=True)
            self.lexecobj.run(os.close, fd)

            if open_type == OPEN_WRITE:
                # Open same file on different process for writing
                fd = self.open_file(self.absfile, OPEN_WRITE, lexec=True)
                self.lexecobj.run(os.close, fd)
        except Exception:
            self.test(False, traceback.format_exc())
            return
        finally:
            if self.fdko:
                # Close open owner file
                self.fdko.close()
            # Close open files
            for fd in fds:
                os.close(fd)
            self.umount()
            self.trace_stop()

        try:
            self.trace_open()
            self.set_pktlist()

            filehandle = None
            if stat:
                # Find the LOOKUP for the file under test
                while True:
                    (lookupcall, lookupreply) = self.find_nfs_op(OP_LOOKUP, src_ipaddr=self.client_ipaddr)
                    if lookupcall is None or lookupcall.NFSop.name == self.filename:
                        # Found LOOKUP for the filename or the end of the
                        # trace file has been reached
                        break
                self.test(lookupcall, "LOOKUP operation should be sent")
                if lookupreply:
                    # GETFH should be the operation following the LOOKUP
                    getfh_obj = self.getop(lookupreply, OP_GETFH)
                    if getfh_obj:
                        # Get the file handle for the file under test
                        filehandle = getfh_obj.fh
                    else:
                        # Could not find GETFH
                        self.test(False, "Could not find GETFH operation in the LOOKUP compound")

            (fh, op_stid, deleg_stid) = self.find_open(filename=self.filename, claimfh=filehandle, deleg_type=deleg_type, anyclaim=True)
            self.verify_open(fh, stat)
            self.test(deleg_stid != None, "%s delegation should be granted" % mode_str)
            save_index = self.pktt.get_index()
            if deleg_stid is None:
                # Delegation was not granted
                return

            filehandles = [fh]
            self.find_layoutget(fh)
            (devcall, devreply, dslist) = self.find_getdeviceinfo()
            self.pktt.rewind(save_index)
            if self.layout:
                filehandles = self.layout['filehandles']

            # Find any other OPENs for the same file
            olist = self.find_open(filename=self.filename)
            self.test(olist[0] is None, "OPEN should not be sent for the same file")

            if lock:
                # Rewind trace file
                self.pktt.rewind()
                (lockcall, lockreply) = self.find_nfs_op(OP_LOCK, src_ipaddr=self.client_ipaddr)
                self.test(lockcall is None, "LOCK should not be sent to the server")

            # Verify I/O packets
            op_type = OP_READ if open_type == OPEN_READ else OP_WRITE
            self.verify_io_packets(op_type, fh, DELEG_STID, deleg_stid)

            # Rewind trace file to saved packet index
            if deleg_type == OPEN_DELEGATE_READ:
                self.pktt.rewind(save_index)
                nio = self.verify_io_requests(deleg_type, deleg_stid, filehandles, src_ipaddr=self.client_ipaddr)
                if nio > 0:
                    unique_io_list = sorted(set(self.test_offsets))
                    expr = len(self.test_offsets) == len(unique_io_list)
                    self.test(expr, "%s should not be sent when reading delegated file from a different process" % mode_str)

            # Find CLOSE request and reply
            self.pktt.rewind(save_index)
            match_str = "NFS.fh == '%s'" % self.pktt.escape(fh)
            (closecall, closereply) = self.find_nfs_op(OP_CLOSE, src_ipaddr=self.client_ipaddr, match=match_str)

            if closecall:
                # Find DELEGRETURN request and reply
                self.pktt.rewind(closecall.record.index)
                (delegreturncall, delegreturnreply) = self.find_nfs_op(OP_DELEGRETURN, src_ipaddr=self.client_ipaddr, match=match_str)
                self.test(delegreturncall, "DELEGRETURN should be sent after the close")
                if delegreturncall:
                    expr = delegreturncall.NFSop.stateid.other == deleg_stid
                    self.test(expr, "DELEGRETURN should be sent with the delegation stateid")
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.close()

    def recall_deleg_test(self, open_type, io_type=None, conflict_type=OP_WRITE, lock=False, nfiles=0, target=False, claim_cur=None):
        """Delegation recall tests"""
        if self.clientobj is None:
            return
        try:
            fd = None
            fdsec = None
            self.fdko = None
            extra_str = ""
            deleg_type = deleg_map[open_type]
            mode_str = deleg_str[deleg_type]
            nfs_version = self.clientobj.nfs_version
            sipaddr = self.clientobj.ipaddr
            sproto = self.clientobj.proto
            sport = self.clientobj.port
            if io_type is None:
                io_type = OPEN_READ if open_type == OPEN_READ else OPEN_WRITE
            io_str = open_str[io_type]
            op_type = OP_READ if io_type == OPEN_READ else OP_WRITE
            if conflict_type == OP_SETATTR:
                conflict_str = "SETATTR (chmod)"
                conflict_op = OP_SETATTR if nfs_version > 3 else NFSPROC3_SETATTR
            elif conflict_type == OP_REMOVE:
                conflict_str = "REMOVE"
                conflict_op = OP_REMOVE if nfs_version > 3 else NFSPROC3_REMOVE
            elif conflict_type == OP_RENAME:
                conflict_str = "RENAME"
                conflict_op = OP_RENAME if nfs_version > 3 else NFSPROC3_RENAME
                conflict_str += " (DST)" if target else " (SRC)"
            elif nfs_version < 4:
                if conflict_type == OP_READ:
                    conflict_str = "READ"
                    conflict_op = NFSPROC3_READ
                    # Use an existing file because reading and empty file
                    # in NFSv3 will not send the READ procedure
                    nfiles = 1
                else:
                    conflict_str = "WRITE"
                    conflict_op = NFSPROC3_WRITE
            else:
                ctype = "READ" if conflict_type == OP_READ else "WRITE"
                conflict_str = "OPEN (%s)" % ctype
                conflict_op = OP_OPEN

            if open_type == OPEN_RDWR:
                iostr = "reading" if io_type == OPEN_READ else "writing"
                extra_str = " using RDWR open while %s" % iostr

            lock_str = " with file lock" if lock else ""

            claim_str = ""
            if claim_cur == os.O_RDONLY:
                claim_io = "READ"
                claim_str = ", having a pending READ open"
            elif claim_cur == os.O_WRONLY:
                claim_io = "WRITE"
                claim_str = ", having a pending WRITE open"

            # Flag to read same file from another client to test the
            # delegation should not be recalled
            other_read_deleg = deleg_type == OPEN_DELEGATE_READ and claim_cur is None

            extra_str += "%s%s" % (lock_str, claim_str)
            self.test_group("Recall %s delegation with %s%s" % (mode_str, conflict_str, extra_str))
            self.setup_test(open_type, io_type, mount=True, nfiles=nfiles, lexec=(claim_cur is not None))

            # Open file, should get a DELEGATION
            try:
                fmsg = ""
                dmsg = "Open file for %s" % open_str[open_type]
                self.dprint('DBG2', "%s [%s]" % (dmsg, self.absfile))
                fd = os.open(self.absfile, open_flags[open_type])
            except OSError as exerr:
                fmsg = ", failed with %s" % exerr
            self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            if lock:
                self.lock_file(fd, io_type, self.absfile, self.lock_offset, self.lock_len)

            iosize = int(self.PAGESIZE/2)

            cio_type = None
            if claim_cur is not None:
                try:
                    fmsg = ""
                    dmsg = "Open file for %s in a different process" % claim_io
                    self.dprint('DBG2', "%s [%s]" % (dmsg, self.absfile))
                    fdsec = self.lexecobj.run(os.open, self.absfile, claim_cur)
                except OSError as exerr:
                    fmsg = ", failed with %s" % exerr
                self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

                try:
                    fmsg = ""
                    dmsg = "Lock file in a different process"
                    cio_type = OPEN_READ if claim_cur == os.O_RDONLY else OPEN_WRITE
                    cio_lstr = "F_RDLCK" if claim_cur == os.O_RDONLY else "F_WRLCK"
                    self.dprint('DBG3', "Lock %s in a different process (F_SETLK, %s) start=%d len=%d" % (self.absfile, cio_lstr, self.lock_poffset, self.lock_len))
                    self.lexecobj.run(file_lock, fdsec, cio_type, self.absfile, self.lock_poffset, self.lock_len)
                except IOError as exerr:
                    fmsg = ", failed with %s" % exerr
                self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            if len(self.basename) > 0:
                if conflict_type == OP_RENAME and not target:
                    aname = self.absfile
                    fname = self.filename
                    self.get_filename()
                    self.absfile  = aname
                    self.filename = fname
                raise BaseName

            try:
                # Read/Write file
                fmsg = ""
                dmsg = "%s file on client holding delegation" % io_str.capitalize()
                self.dprint("DBG3", "%s [%s]" % (dmsg, self.absfile))
                if io_type == OPEN_READ:
                    os.read(fd, iosize)
                else:
                    os.write(fd, self.data_pattern(0, iosize, PATTERN))
            except OSError as exerr:
                fmsg = ", failed with %s" % exerr
            self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)
            self.delay_io()

            # Read same file from another client -- delegation should not be
            # recalled and delegation should be granted
            if other_read_deleg:
                # Other READ opens will not recall the delegation
                self.get_deleg_remote()

            try:
                fmsg = ""
                if conflict_type == OP_SETATTR:
                    dmsg = "Change permissions on the file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    self.rexecobj.run(os.chmod, self.absfile, 0777)
                elif conflict_type == OP_REMOVE:
                    dmsg = "Remove the file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    self.rexecobj.run(os.unlink, self.absfile)
                elif conflict_type == OP_RENAME:
                    if target:
                        fname = self.files[-2]
                        srcname = self.abspath(fname)
                        dmsg = "Rename into the file (DST) from another client"
                        self.dprint("DBG2", "%s to recall delegation [%s -> %s]" % (dmsg, fname, self.filename))
                        self.rexecobj.run(os.rename, srcname, self.absfile)
                    else:
                        aname = self.absfile
                        fname = self.filename
                        self.get_filename()
                        dmsg = "Rename the file (SRC) from another client"
                        self.dprint("DBG2", "%s to recall delegation [%s -> %s]" % (dmsg, fname, self.filename))
                        newname = self.absfile
                        self.absfile  = aname
                        self.filename = fname
                        self.rexecobj.run(os.rename, self.absfile, newname)
                elif conflict_type == OP_READ:
                    dmsg = "Read same file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    fdrd = self.rexecobj.run(os.open, self.absfile, os.O_RDONLY)
                    data = self.rexecobj.run(os.read, fdrd, 1024)
                    self.rexecobj.run(os.close, fdrd)
                elif self.truncate:
                    dmsg = "Write same file (truncate before writing) from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    fdwr  = self.rexecobj.run(os.open, self.absfile, os.O_WRONLY|os.O_TRUNC)
                    count = self.rexecobj.run(os.write, fdwr, self.data_pattern(0, 1024, "x"))
                    self.rexecobj.run(os.close, fdwr)
                else:
                    dmsg = "Write same file from another client"
                    self.dprint("DBG2", "%s to recall delegation [%s]" % (dmsg, self.absfile))
                    fdwr  = self.rexecobj.run(os.open, self.absfile, os.O_WRONLY|os.O_APPEND)
                    count = self.rexecobj.run(os.write, fdwr, self.data_pattern(0, 1024, "X"))
                    self.rexecobj.run(os.close, fdwr)
            except OSError as exerr:
                fmsg = ", failed with %s" % exerr
            self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)

            try:
                fmsg = ""
                dmsg = "%s file after conflicting operation" % io_str.capitalize()
                self.dprint("DBG3", "%s [%s]" % (dmsg, self.absfile))
                # Read/Write file
                if io_type == OPEN_READ:
                    # Read should not fail
                    expfail = False
                    os.read(fd, self.filesize - iosize)
                else:
                    # Check for errors on the write since the server may return
                    # an error when the file has been removed by another client
                    expfail = conflict_type == OP_REMOVE or (conflict_type == OP_RENAME and target)
                    os.write(fd, self.data_pattern(iosize, self.filesize - iosize, PATTERN))
                    # Flush data so if there is an error on a write it will
                    # happened here instead on the close
                    os.fdatasync(fd)
            except OSError as exerr:
                if expfail:
                    expected = errno.errorcode[errno.ESTALE]
                    error = errno.errorcode[exerr.errno]
                    fmsg =  ": expecting %s, got %s" % (expected, error)
                    self.dprint("DBG4", "%s returns: %s" % (dmsg, str(exerr)))
                    self.test(exerr.errno == errno.ESTALE, "%s may return an error" % dmsg, failmsg=fmsg)
                else:
                    fmsg = ", failed with %s" % exerr
            if not expfail:
                self.test(len(fmsg) == 0, "%s should succeed" % dmsg, failmsg=fmsg)
            self.delay_io()
        except BaseName:
            pass
        except:
            self.test(False, traceback.format_exc())
        finally:
            if fd:
                # Close file
                self.dprint('DBG4', "Close %s" % self.absfile)
                os.close(fd)
            if self.fdko:
                # Close open owner file
                self.fdko.close()
            if fdsec:
                self.dprint('DBG4', "Close %s on second process" % self.absfile)
                self.lexecobj.run(os.close, fdsec)
            self.umount()
            if self.clientobj:
                self.clientobj.umount()
            self.trace_stop()

        try:
            if conflict_type == OP_REMOVE or (conflict_type == OP_RENAME and target):
                self.set_nfserr_list(
                    nfs3list=[NFS3ERR_NOENT],
                    nfs4list=[NFS4ERR_NOENT, NFS4ERR_STALE, NFS4ERR_BAD_STATEID],
                )
            self.trace_open()
            self.set_pktlist()

            (open_fh, open_stid, deleg_stid) = self.find_open(filename=self.filename, deleg_type=deleg_type, src_ipaddr=self.client_ipaddr)
            self.verify_open(open_fh)
            self.test(deleg_stid != None, "%s delegation should be granted" % mode_str)
            save_index = self.pktt.get_index()
            open1_index = save_index
            if deleg_stid is None:
                # Delegation was not granted
                return

            open_stateid = None
            if open_stid is not None:
                open_stateid = self.openreply.NFSop.stateid

            filehandles = [open_fh]
            self.find_layoutget(open_fh)
            (devcall, devreply, dslist) = self.find_getdeviceinfo()
            self.pktt.rewind(save_index)
            if self.layout:
                filehandles = self.layout['filehandles']

            fh1 = None
            if other_read_deleg:
                # Find OPEN (READ) call from the second client
                (fh1, op_stid1, deleg_stid1) = self.find_open(filename=self.filename, src_ipaddr=sipaddr, proto=sproto, nfs_version=nfs_version)
                save_index = self.pktt.get_index()

            # Find DELEGRETURN request and reply
            (delegreturncall, delegreturnreply) = self.find_nfs_op(OP_DELEGRETURN, src_ipaddr=self.client_ipaddr)
            if delegreturncall:
                delegreturn_index = delegreturncall.record.index
            self.pktt.rewind(save_index)

            # Find OPEN call from the second client
            src_other_client_str = "IP.dst == '%s' and %s.dst_port == %d" % (self.server_ipaddr, sproto.upper(), sport)
            src_other_client_str += " and IP.src == '%s' and " % sipaddr
            conflict_match_str = src_other_client_str + "NFS.argop == %d" % conflict_op
            if conflict_op == OP_OPEN:
                conflict_match_str += " and (NFS.claim.name == '%s' or" % self.filename
                conflict_match_str += " (NFS.fh == '%s' and NFS.claim.claim == %d))" % (self.pktt.escape(open_fh), CLAIM_FH)
            elif target and conflict_type == OP_RENAME:
                conflict_match_str += " and NFS.newname == '%s'" % self.filename
            elif conflict_type in [OP_REMOVE, OP_RENAME]:
                conflict_match_str += " and NFS.name == '%s'" % self.filename
            elif conflict_op in [NFSPROC3_READ, NFSPROC3_WRITE]:
                if fh1 is None:
                    # Find the NFSv3 LOOKUP to get the file handle
                    (fh1, op_stid1, deleg_stid1) = self.find_open(filename=self.filename, src_ipaddr=sipaddr, proto=sproto, nfs_version=nfs_version)
                expr = fh1 is not None
                self.test(expr, "LOOKUP should be sent from second client")
                if expr:
                   conflict_match_str += " and NFS.fh == '%s'" % self.pktt.escape(fh1)

            openreply = None
            while True:
                opencall = self.pktt.match(conflict_match_str)
                if opencall is None:
                    break

                # Make sure conflicting operation reply status from the
                # second client is not NFS4ERR_DELAY
                xid = opencall.rpc.xid
                matchstr = "RPC.xid == %d and NFS.status in (%d, %d)" % (xid, NFS4_OK, NFS4ERR_DELAY)
                openreply = self.pktt.match(matchstr, maxindex=delegreturn_index)
                if openreply is None or openreply.nfs.status == NFS4_OK:
                    break

            if opencall is None:
                self.test(False, "%s should be sent from second client" % conflict_str)
                return
            conflict_index = opencall.record.index + 1

            # Boolean for pending test which should not recall the delegation
            read_write = deleg_type == OPEN_DELEGATE_READ and claim_cur == os.O_WRONLY

            if other_read_deleg:
                self.pktt.rewind(save_index)
                # Verify no CB_RECALL is sent to client under test
                (cbcall, cbreply) = self.find_nfs_op(OP_CB_RECALL, ipaddr=self.client_ipaddr, port=None, src_ipaddr=self.server_ipaddr, maxindex=conflict_index)
                self.test(cbcall is None, "CB_RECALL should not be sent to the client after a READ OPEN is received from a second client")
                if deleg_stid1 != None:
                    self.test(cbcall is None, "CB_RECALL should not be sent to the client after a second client is granted a READ delegation")
                self.pktt.rewind(conflict_index)

            lock_stid = None
            if lock:
                self.pktt.rewind(save_index)
                # Verify no CB_RECALL is sent to client under test
                (cbcall, cbreply) = self.find_nfs_op(OP_CB_RECALL, ipaddr=self.client_ipaddr, port=None, src_ipaddr=self.server_ipaddr, maxindex=conflict_index)
                self.test(cbcall is None, "%s delegation should not be recalled after locking the file" % mode_str)

                (lockcall, lockreply) = self.find_nfs_op(OP_LOCK, src_ipaddr=self.client_ipaddr, maxindex=conflict_index)
                if read_write:
                    self.test(lockcall, "LOCK should be sent when holding a %s delegation and the file is opened on the same client for writing" % mode_str)
                    if lockreply:
                        lock_stid = lockreply.NFSop.stateid.other
                else:
                    self.test(lockcall is None, "LOCK should not be sent when holding a %s delegation on the file" % mode_str)
                self.pktt.rewind(conflict_index)

            if read_write:
                # The client returns the delegation
                self.test(delegreturncall, "DELEGRETURN should be sent when the file is opened on the same client for writing")
                if delegreturncall:
                    expr = delegreturncall.NFSop.stateid.other == deleg_stid
                    self.test(expr, "DELEGRETURN should be sent with the %s delegation stateid" % mode_str)

            self.test(opencall, "%s should be sent from second client" % conflict_str)
            if conflict_op == OP_SETATTR:
                expr = opencall.NFSop.stateid.seqid == self.stateid_anonymous.seqid \
                   and opencall.NFSop.stateid.other == self.stateid_anonymous.other
                self.test(expr, "%s should be sent with the special anonymous stateid (0, 0)" % conflict_str)
            elif conflict_op == OP_REMOVE:
                expr = opencall.NFSop.name == self.filename
                self.test(expr, "%s should be sent with file holding the delegation as the name" % conflict_str)
            elif conflict_op == OP_RENAME:
                if target:
                    expr = opencall.NFSop.newname == self.filename
                    self.test(expr, "%s should be sent with file holding the delegation as the target" % conflict_str)
                else:
                    expr = opencall.NFSop.name == self.filename
                    self.test(expr, "%s should be sent with file holding the delegation as the source" % conflict_str)

            # Find CB_RECALL sent to client under test
            (cbcall, cbreply) = self.find_nfs_op(OP_CB_RECALL, ipaddr=self.client_ipaddr, port=None, src_ipaddr=self.server_ipaddr)
            if read_write:
                # The client has returned the delegation so no CB_RECALL
                self.test(cbcall is None, "CB_RECALL should not be sent to the client after a conflicting %s is received from a second client" % conflict_str)
                xid = opencall.rpc.xid
                openreply = self.pktt.match("RPC.xid == %d and NFS.resop == %d" % (xid, conflict_op))
                self.test(openreply, "%s reply should be sent to the second client" % conflict_str)
                # Verify I/O packets
                stid_type = LOCK_STID if lock and lock_stid else OPEN_STID
                stateid = lock_stid if stid_type == LOCK_STID else open_stid
                self.verify_io_packets(op_type, open_fh, stid_type, stateid, delegret=True)
            else:
                self.test(cbcall, "CB_RECALL should be sent to the client after a conflicting %s is received from a second client" % conflict_str)
            if cbcall is None:
                return
            cbrecall_index = self.pktt.get_index()
            self.test(cbcall.NFSop.stateid.other == deleg_stid, "CB_RECALL should recall %s delegation granted to client" % mode_str)

            # Find OPEN sent from the client right before returning the delegation
            (fh, op_stid2, deleg_stid2) = self.find_open(filename=self.filename, deleg_stateid=deleg_stid, src_ipaddr=self.client_ipaddr, fh=open_fh)
            open_index = self.pktt.get_index()
            if fh is not None or claim_cur in [os.O_RDONLY, os.O_WRONLY]:
                expr1 = deleg_type == OPEN_DELEGATE_READ and claim_cur == os.O_RDONLY
                expr2 = deleg_type == OPEN_DELEGATE_WRITE and claim_cur == os.O_WRONLY
                # OPEN is only sent if main open and pending open are different
                if not (op_stid2 is None and (expr1 or expr2)):
                    self.test(op_stid2, "OPEN with CLAIM_DELEGATE_CUR is sent before returning the %s delegation after CB_RECALL" % mode_str)
            if fh is not None:
                self.test(op_stid2 == open_stid, "OPEN stateid should be the same as the original OPEN stateid")
                op_stateid = self.openreply.NFSop.stateid
                expr = op_stateid.seqid == open_stateid.seqid + 1
                self.test(expr, "OPEN stateid seqid should be increased by one from the original OPEN stateid")
                self.test(deleg_stid2 is None, "Delegation should not be granted when re-opening the file before returning the %s delegation after CB_RECALL" % mode_str)

            if deleg_type == OPEN_DELEGATE_WRITE:
                # Find out how much data has already been flushed right
                # before getting the CB_RECALL
                self.pktt.rewind(open1_index)
                nio = self.verify_io_requests(deleg_type, deleg_stid, filehandles, src_ipaddr=self.client_ipaddr, maxindex=cbrecall_index)
                if iosize > sum(self.test_counts):
                    # Not all data has been flushed,
                    # so find the WRITEs before DELEGRETURN
                    self.pktt.rewind(cbrecall_index)
                    nio = self.verify_io_requests(deleg_type, deleg_stid, filehandles, src_ipaddr=self.client_ipaddr, maxindex=open_index)
                    if nio > 0:
                        # Make this test optional since latest kernels do not
                        # flush the data before returning the delegation
                        self.test(True, "Client flushes written data before returning the WRITE delegation")
                else:
                    self.test(True, "Client has already flushed all written data before CB_RECALL")
                self.pktt.rewind(open_index)

            lock_stid = None
            lock_owner = None
            if lock and delegreturncall:
                # Verify the LOCK before DELEGRETURN
                lop_stid = open_stid if op_stid2 is None else op_stid2
                lock_stid = self.verify_lock(io_type, mode_str, lop_stid, self.lock_offset, open_index, delegreturn_index)
                if self.pktcall:
                    # Save lock owner
                    lock_owner = self.pktcall.NFSop.locker.open_owner.lock_owner.owner
                if cio_type is not None:
                    # Verify the LOCK before DELEGRETURN -- second process
                    msg = " for the second process"
                    self.verify_lock(cio_type, mode_str, lop_stid, self.lock_poffset, open_index, delegreturn_index, msg=msg, lock_owner=lock_owner, lock_stid=lock_stid)

            self.test(delegreturncall, "DELEGRETURN should be sent")
            if delegreturncall is None:
                return
            expr = delegreturncall.NFSop.stateid.other == deleg_stid
            self.test(expr, "DELEGRETURN should be sent with the stateid of %s delegation being recalled" % mode_str)

            self.pktt.rewind(delegreturn_index)

            # Find conflicting operation reply from the second client
            xid = opencall.rpc.xid
            openreply = self.pktt.match("RPC.xid == %d and NFS.resop == %d" % (xid, conflict_op))
            self.test(openreply != None, "%s reply should be sent to the second client after the %s delegation has been returned" % (conflict_str, mode_str))
            if openreply is None:
                return
            mds_stat = [NFS4_OK, NFS3_OK]
            ds_stat  = [NFS4_OK]
            stid_type = LOCK_STID if lock and lock_stid else OPEN_STID
            stateid = lock_stid if stid_type == LOCK_STID else open_stid
            if conflict_op == OP_OPEN:
                self.test(openreply.NFSop.delegation.deleg_type == OPEN_DELEGATE_NONE, "Delegation should not be granted for the second client")
            elif conflict_type == OP_REMOVE or (conflict_type == OP_RENAME and target):
                if deleg_type == OPEN_DELEGATE_WRITE:
                    ds_stat = [NFS4ERR_STALE, NFS4ERR_BAD_STATEID]
                else:
                    ds_stat = [NFS4ERR_BAD_STATEID]
                mds_stat = [NFS4ERR_STALE]

            # Verify I/O packets
            self.verify_io_packets(op_type, open_fh, stid_type, stateid, status=mds_stat, ds_status=ds_stat, delegret=True)
        except Exception:
            self.test(False, traceback.format_exc())
        finally:
            self.pktt.close()

    def basic01_test(self):
        """Basic read delegation test"""
        self.basic_deleg_test(OPEN_READ)

    def basic02_test(self):
        """Basic write delegation test"""
        self.basic_deleg_test(OPEN_WRITE)

    def basic03_test(self):
        """Basic read delegation test with file stat"""
        self.basic_deleg_test(OPEN_READ, stat=True)

    def basic04_test(self):
        """Basic write delegation test with file stat"""
        self.basic_deleg_test(OPEN_WRITE, stat=True, nfiles=1)

    def basic05_test(self):
        """Basic read delegation test with file lock"""
        self.basic_deleg_test(OPEN_READ, lock=True)

    def basic06_test(self):
        """Basic write delegation test with file lock"""
        self.basic_deleg_test(OPEN_WRITE, lock=True)

    def basic07_test(self):
        """Basic write delegation test using RDWR open while reading"""
        self.basic_deleg_test(OPEN_RDWR, io_type=OPEN_READ)

    def basic08_test(self):
        """Basic write delegation test using RDWR open while writing"""
        self.basic_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE)

    def basic09_test(self):
        """Basic read delegation test using RDWR open while reading with file stat"""
        self.basic_deleg_test(OPEN_RDWR, io_type=OPEN_READ, stat=True)

    def basic10_test(self):
        """Basic write delegation test using RDWR open while writing with file stat"""
        self.basic_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, stat=True, nfiles=1)

    def basic11_test(self):
        """Basic write delegation test using RDWR open while reading with file lock"""
        self.basic_deleg_test(OPEN_RDWR, io_type=OPEN_READ, lock=True)

    def basic12_test(self):
        """Basic write delegation test using RDWR open while writing with file lock"""
        self.basic_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, lock=True)

    def recall01_test(self):
        """Recall read delegation by writing from a second client"""
        self.recall_deleg_test(OPEN_READ)

    def recall02_test(self):
        """Recall write delegation by writing from a second client"""
        self.recall_deleg_test(OPEN_WRITE)

    def recall03_test(self):
        """Recall read delegation by writing from a second client with file lock"""
        self.recall_deleg_test(OPEN_READ, lock=True)

    def recall04_test(self):
        """Recall write delegation by writing from a second client with file lock"""
        self.recall_deleg_test(OPEN_WRITE, lock=True)

    def recall05_test(self):
        """Recall write delegation by reading from a second client"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_READ)

    def recall06_test(self):
        """Recall write delegation by reading from a second client with file lock"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_READ, lock=True)

    def recall07_test(self):
        """Recall read delegation by changing the permissions to the file"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_SETATTR)

    def recall08_test(self):
        """Recall write delegation by changing the permissions to the file"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_SETATTR)

    def recall09_test(self):
        """Recall read delegation by changing the permissions to the file with file lock"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_SETATTR, lock=True)

    def recall10_test(self):
        """Recall write delegation by changing the permissions to the file with file lock"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_SETATTR, lock=True)

    def recall11_test(self):
        """Recall read delegation by removing the file"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_REMOVE, nfiles=1)

    def recall12_test(self):
        """Recall write delegation by removing the file"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_REMOVE, nfiles=1)

    def recall13_test(self):
        """Recall read delegation by removing the file with file lock"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_REMOVE, nfiles=1, lock=True)

    def recall14_test(self):
        """Recall write delegation by removing the file with file lock"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_REMOVE, nfiles=1, lock=True)

    def recall15_test(self):
        """Recall read delegation by renaming the file"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_RENAME, nfiles=1)

    def recall16_test(self):
        """Recall write delegation by renaming the file"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_RENAME, nfiles=1)

    def recall17_test(self):
        """Recall read delegation by renaming the file with file lock"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_RENAME, nfiles=1, lock=True)

    def recall18_test(self):
        """Recall write delegation by renaming the file with file lock"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_RENAME, nfiles=1, lock=True)

    def recall19_test(self):
        """Recall read delegation by renaming into the file"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_RENAME, nfiles=2, target=True)

    def recall20_test(self):
        """Recall write delegation by renaming into the file"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_RENAME, nfiles=2, target=True)

    def recall21_test(self):
        """Recall read delegation by renaming into the file with file lock"""
        self.recall_deleg_test(OPEN_READ, conflict_type=OP_RENAME, nfiles=2, target=True, lock=True)

    def recall22_test(self):
        """Recall write delegation by renaming into the file with file lock"""
        self.recall_deleg_test(OPEN_WRITE, conflict_type=OP_RENAME, nfiles=2, target=True, lock=True)

    def recall23_test(self):
        """Recall read delegation by writing from a second client with file lock,
           having a pending read open"""
        self.recall_deleg_test(OPEN_READ, claim_cur=os.O_RDONLY, lock=True)

    def recall24_test(self):
        """Recall read delegation by writing from a second client with file lock,
           having a pending write open.
           Delegation is returned by the client when the second open is done so
           there is no delegation recall"""
        self.recall_deleg_test(OPEN_READ, claim_cur=os.O_WRONLY, lock=True)

    def recall25_test(self):
        """Recall write delegation by writing from a second client with file lock,
           having a pending read open"""
        self.recall_deleg_test(OPEN_WRITE, claim_cur=os.O_RDONLY, lock=True)

    def recall26_test(self):
        """Recall write delegation by writing from a second client with file lock,
           having a pending write open"""
        self.recall_deleg_test(OPEN_WRITE, claim_cur=os.O_WRONLY, lock=True)

    def recall27_test(self):
        """Recall write delegation by reading from a second client using RDWR
           open while reading"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_READ)

    def recall28_test(self):
        """Recall write delegation by reading from a second client using RDWR
           open while writing"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_READ)

    def recall29_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while reading"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_WRITE)

    def recall30_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while writing"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_WRITE)

    def recall31_test(self):
        """Recall write delegation by reading from a second client using RDWR
           open while reading with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_READ, lock=True)

    def recall32_test(self):
        """Recall write delegation by reading from a second client using RDWR
           open while writing with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_READ, lock=True)

    def recall33_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while reading with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_WRITE, lock=True)

    def recall34_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while writing with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_WRITE, lock=True)

    def recall35_test(self):
        """Recall write delegation by changing the permissions to the file
           from a second client using RDWR open while reading"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_SETATTR)

    def recall36_test(self):
        """Recall write delegation by changing the permissions to the file
           from a second client using RDWR open while writing"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_SETATTR)

    def recall37_test(self):
        """Recall write delegation by changing the permissions to the file
           from a second client using RDWR open while reading with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_SETATTR, lock=True)

    def recall38_test(self):
        """Recall write delegation by changing the permissions to the file
           from a second client using RDWR open while writing with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_SETATTR, lock=True)

    def recall39_test(self):
        """Recall write delegation by removing the file from a second client
           using RDWR open while reading"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_REMOVE, nfiles=1)

    def recall40_test(self):
        """Recall write delegation by removing the file from a second client
           using RDWR open while writing"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_REMOVE, nfiles=1)

    def recall41_test(self):
        """Recall write delegation by removing the file from a second client
           using RDWR open while reading with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_REMOVE, nfiles=1, lock=True)

    def recall42_test(self):
        """Recall write delegation by removing the file from a second client
           using RDWR open while writing with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_REMOVE, nfiles=1, lock=True)

    def recall43_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while reading"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_RENAME, nfiles=1)

    def recall44_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while writing"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_RENAME, nfiles=1)

    def recall45_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while reading with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_RENAME, nfiles=1, lock=True)

    def recall46_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while writing with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_RENAME, nfiles=1, lock=True)

    def recall47_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while reading"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_RENAME, nfiles=2, target=True)

    def recall48_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while writing"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_RENAME, nfiles=2, target=True)

    def recall49_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while reading with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, conflict_type=OP_RENAME, nfiles=2, target=True, lock=True)

    def recall50_test(self):
        """Recall write delegation by renaming the file from a second client
           using RDWR open while writing with file lock"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, conflict_type=OP_RENAME, nfiles=2, target=True, lock=True)

    def recall51_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while reading with file lock, having a pending read open"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, claim_cur=os.O_RDONLY, lock=True)

    def recall52_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while reading with file lock, having a pending write open"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_READ, claim_cur=os.O_WRONLY, lock=True)

    def recall53_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while writing with file lock, having a pending read open"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, claim_cur=os.O_RDONLY, lock=True)

    def recall54_test(self):
        """Recall write delegation by writing from a second client using RDWR
           open while writing with file lock, having a pending write open"""
        self.recall_deleg_test(OPEN_RDWR, io_type=OPEN_WRITE, claim_cur=os.O_WRONLY, lock=True)

################################################################################
# Entry point
x = DelegTest(usage=USAGE, testnames=TESTNAMES, testgroups=TESTGROUPS, sid=SCRIPT_ID)

try:
    x.setup(nfiles=2)

    # Run all the tests
    x.run_tests()
except Exception:
    x.test(False, traceback.format_exc())
finally:
    if x.clientobj is not None and x.clientobj.mounted:
        # Unmount server on remote client
        x.clientobj.umount()
    x.cleanup()
    x.exit()
